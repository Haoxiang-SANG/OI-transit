<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/sh_typical.min.css">
		<title>完整多项式模板</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/js/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>完整多项式模板 (乘除、指对、分治、求值、插值) <sub><del class="text-muted">(继续卡常版)</del></sub></h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">// This is a polynomial template for C++11
#include &lt;bits/stdc++.h&gt;
#define EB emplace_back
#define lg2 std::__lg

typedef long long ll;
const int N = 530000, mod = 998244353, iv2 = (mod + 1) / 2, root = 31;
typedef int vec[N], *pvec;
typedef std::pair &lt;int, int&gt; pr;
typedef std::vector &lt;int&gt; vector;

vec inv;

inline int min(const int x, const int y) {return x &lt; y ? x : y;}
inline int max(const int x, const int y) {return x &lt; y ? y : x;}
inline int &amp; reduce(int &amp;x) {return x += x &gt;&gt; 31 &amp; mod;}
inline int &amp; neg(int &amp;x) {return x = (!x - 1) &amp; (mod - x);}
ll PowerMod(ll a, int n, ll c = 1) {for (; n; n &gt;&gt;= 1, a = a * a % mod) if (n &amp; 1) c = c * a % mod; return c;}

void init() {
	int i;
	for (inv[1] = 1, i = 2; i &lt; N; ++i) inv[i] = ll(mod - mod / i) * inv[mod % i] % mod;
}

namespace Poly {
	int l, n;
	vec rev, x, y;

	// Input and output
	void in(int deg, pvec f) {for (int i = 0; i &lt;= deg; ++i) scanf("%d", f + i);}

	void out(int deg, pvec f, const char *_name) {
		printf("%s(x) =", _name);
		for (int i = 0; i &lt;= deg; ++i) printf(" %+d x^%d", (int)(f[i] - (mod &amp; -(f[i] &gt;= iv2))), i);
		putchar(10);
	}

	void series(int deg, pvec f) {for (int i = 0; i &lt;= deg; ++i) printf("%d%c", f[i], i == deg ? 10 : 32);}

	#define fy_out(deg, f) Poly::out(deg, f, #f)

	// Fast Number Theory Transform
	void NTT_init(int len) {
		if (l == len) return; n = 1 &lt;&lt; (l = len);
		ll g = PowerMod(root, 1 &lt;&lt; (23 - l));
		*x = 1, *rev = 0;
		for (int i = 1; i &lt; n; ++i)
			x[i] = x[i - 1] * g % mod, rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (l - 1);
	}

	void DNTT(int *d, int *t) {
		int i, *j, *k, len = 1, delta = n, R;
		for (i = 0; i &lt; n; ++i) t[rev[i]] = d[i];
		for (i = 0; i &lt; l; ++i) {
			delta &gt;&gt;= 1;
			for (k = x, j = y; j &lt; y + len; k += delta, ++j) *j = *k;
			for (j = t; j &lt; t + n; j += len &lt;&lt; 1)
				for (k = j; k &lt; j + len; ++k)
					R = (ll)y[k - j] * k[len] % mod,
					k[len] = (*k - R &lt; 0 ? *k - R + mod : *k - R),
					*k = (*k + R &gt;= mod ? *k + R - mod : *k + R);
			len &lt;&lt;= 1;
		}
	}

	vec B1, B2, B3, B4, B5, B6, B7;

	// Multiplication (use one buffer, 3-dft of length 2n)
	void Mul(int deg, pvec a, pvec b, pvec c) {
		if (!deg) {*c = (ll)*a * *b % mod; return;}
		NTT_init(lg2(deg) + 1);
		int i; ll iv = mod - (mod - 1) / n;
		DNTT(a, c), DNTT(b, B1);
		for (i = 0; i &lt; n; ++i) B1[i] = (ll)B1[i] * c[i] % mod;
		DNTT(B1, c), std::reverse(c + 1, c + n);
		for (i = 0; i &lt; n; ++i) c[i] = c[i] * iv % mod;
	}

	// Inversion (use four buffers, 5-dft)
	void Inv(int deg, pvec a, pvec b) {
		int i, len; ll iv = 1; assert(*a);
		if (*b = PowerMod(*a, mod - 2), deg &lt;= 1) return;
		memset(b + 1, 0, i = 8 &lt;&lt; lg2(deg - 1)), memset(B1, 0, i), *B1 = *a;

		for (len = 0; 1 &lt;&lt; len &lt; deg; ++len) {
			NTT_init(len + 1), iv = (iv &gt;&gt; 1) + iv2;

			memcpy(B1 + (n &gt;&gt; 1), a + (n &gt;&gt; 1), n &lt;&lt; 1), DNTT(b, B2), DNTT(B1, B3);
			for (i = 0; i &lt; n; ++i) B3[i] = (ll)B3[i] * B2[i] % mod; DNTT(B3, B4);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) B4[i] = B4[n - i] * iv % mod;

			memset(B4, 0, n &lt;&lt; 1), DNTT(B4, B3);
			for (i = 0; i &lt; n; ++i) B3[i] = (ll)B3[i] * B2[i] % mod; DNTT(B3, B4);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) b[i] = B4[n - i] * (mod - iv) % mod;
		}
	}

	// Division and Modulo Operation (use buffer 4, 5)
	void DivMod(int degA, int degB, pvec a, pvec b, pvec q, pvec r) {
		if (degA &lt; degB) {memcpy(r, a, degA + 1 &lt;&lt; 2); memset(r + (degA + 1), 0, degB - degA &lt;&lt; 2); return;}
		int degQ = degA - degB, i, j = (degQ ? 1 &lt;&lt; lg2(degQ) + 2 : 4);
		for (i = 0; i &lt;= degQ &amp;&amp; i &lt;= degB; ++i) B4[i] = b[degB - i];
		for (; i &lt; j; ++i) B4[i] = 0;
		Inv(degQ + 1, B4, B5);
		for (i = 0; i &lt;= degQ; ++i) B4[i] = a[degA - i];
		for (; i &lt; n; ++i) B4[i] = B5[i] = 0;
		Mul(degQ * 2, B4, B5, q);
		std::reverse(q, q + (degQ + 1));
		NTT_init(lg2(degA) + 1);
		for (i = degQ + 1; i &lt; n; ++i) q[i] = 0;
		for (i = 0; i &lt;= degB; ++i) B4[i] = b[i];
		for (; i &lt; n; ++i) B4[i] = 0;
		Mul(degA, B4, q, r);
		for (i = 0; i &lt; degB; ++i) reduce(r[i] = a[i] - r[i]);
	}

	// Multiplication with std::vector (use three buffers, 3-dft)
	void Mul(vector &amp;a, vector &amp;b, vector &amp;ret) {
		int degA = a.size() - 1, degB = b.size() - 1;
		if (!(degA || degB)) {ret.EB((ll)a[0] * b[0] % mod); return;}
		NTT_init(lg2(degA + degB) + 1);
		int i; ll iv = mod - (mod - 1) / n;
		memcpy(B1, a.data(), (degA + 1) &lt;&lt; 2), memset(B1 + (degA + 1), 0, (n - degA - 1) &lt;&lt; 2);
		memcpy(B2, b.data(), (degB + 1) &lt;&lt; 2), memset(B2 + (degB + 1), 0, (n - degB - 1) &lt;&lt; 2);
		DNTT(B1, B3), DNTT(B2, B1);
		for (i = 0; i &lt; n; ++i) B1[i] = (ll)B1[i] * B3[i] % mod;
		DNTT(B1, B3), std::reverse(B3 + 1, B3 + n); ret.clear(), ret.reserve(degA + degB + 1);
		for (i = 0; i &lt;= degA + degB; ++i) ret.EB(B3[i] * iv % mod);
	}

	// Differential
	void Diff(int deg, pvec a, pvec b) {for (int i = 1; i &lt;= deg; ++i) b[i - 1] = (ll)a[i] * i % mod;}

	// Integral
	void Intg(int deg, pvec a, pvec b, int ct = 0) {for (int i = deg; i; --i) b[i] = (ll)a[i - 1] * inv[i] % mod; *b = ct;}

	// f'[x] / f[x] (use five buffers, 6.5-dft)
	void DifQuo(int deg, pvec a, pvec b) {
		assert(*a);
		if (deg &lt;= 1) {*b = PowerMod(*a, mod - 2, a[1]); return;}

		int i, len = lg2(deg - 1); ll iv = mod - ((mod - 1) &gt;&gt; (len + 1));
		Inv((deg + 1) / 2, a, B5), NTT_init(len + 1),
		memset(B5 + (n &gt;&gt; 1), 0, n &lt;&lt; 1), DNTT(B5, B2),

		Diff(deg, a, B1), memcpy(B5, B1, n &lt;&lt; 1),
		memset(B5 + (n &gt;&gt; 1), 0, n &lt;&lt; 1), DNTT(B5, B3);

		for (i = 0; i &lt; n; ++i) B3[i] = (ll)B3[i] * B2[i] % mod;
		DNTT(B3, b), *b = *b * iv % mod;
		for (i = 1; i &lt; n &gt;&gt; 1; ++i) b[i] = b[n - i] * iv % mod;
		memset(b + (n &gt;&gt; 1), 0, n &lt;&lt; 1);

		DNTT(b, B4), DNTT(a, B3);
		for (i = 0; i &lt; n; ++i) B3[i] = (ll)B3[i] * B4[i] % mod; DNTT(B3, B4);
		for (i = n &gt;&gt; 1; i &lt; n; ++i) B4[i] = (B4[n - i] * iv + mod - B1[i]) % mod;

		memset(B4, 0, n &lt;&lt; 1), DNTT(B4, B3);
		for (i = 0; i &lt; n; ++i) B3[i] = (ll)B3[i] * B2[i] % mod; DNTT(B3, B4);
		for (i = n &gt;&gt; 1; i &lt; n; ++i) b[i] = B4[n - i] * (mod - iv) % mod;
	}

	// Logarithm (use DifQuo)
	inline void Ln(int deg, pvec a, pvec b) {assert(*a == 1), --deg ? (DifQuo(deg, a, b), Intg(deg, b, b)) : void(*b = 0);}

	// Exponentiation (use seven buffers, 12-dft)
	void Exp(int deg, pvec a, pvec b) {
		int i, len; ll iv = iv2; pvec c = B7; assert(!*a);
		if (*b = 1, deg &lt;= 1) return;
		if (b[1] = a[1], deg == 2) return;

		memset(b + 2, 0, i = 8 &lt;&lt; lg2(deg - 1)), memset(c, 0, i), memset(B1, 0, i),
		*c = 1, neg(c[1] = b[1]);

		for (len = 1; 1 &lt;&lt; len &lt; deg; ++len) {
			NTT_init(len + 1), iv = (iv &gt;&gt; 1) + iv2;

			DNTT(c, B2), DNTT(b, B3);
			for (i = 0; i &lt; n; ++i) B4[i] = (ll)B3[i] * B2[i] % mod; DNTT(B4, B5);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) B5[i] = B5[n - i] * iv % mod;

			memset(B5, 0, n &lt;&lt; 1), DNTT(B5, B4);
			for (i = 0; i &lt; n; ++i) B4[i] = (ll)B4[i] * B2[i] % mod; DNTT(B4, B5);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) B5[i] = B5[n - i] * (mod - iv) % mod;

			memcpy(B5, c, n &lt;&lt; 1), DNTT(B5, B6);
			Diff(n &gt;&gt; 1, b, B1), DNTT(B1, B4);
			for (i = 0; i &lt; n; ++i) B4[i] = (ll)B4[i] * B6[i] % mod; DNTT(B4, B6);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) reduce(B5[i] = (a[i] - B6[n - i + 1] * iv % mod * inv[i]) % mod);

			memset(B5, 0, n &lt;&lt; 1), DNTT(B5, B4);
			for (i = 0; i &lt; n; ++i) B4[i] = (ll)B4[i] * B3[i] % mod; DNTT(B4, B5);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) b[i] = B5[n - i] * iv % mod;

			if (2 &lt;&lt; len &gt;= deg) return;

			DNTT(b, B3);
			for (i = 0; i &lt; n; ++i) B3[i] = (ll)B3[i] * B2[i] % mod; DNTT(B3, B4);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) B4[i] = B4[n - i] * iv % mod;

			memset(B4, 0, n &lt;&lt; 1), DNTT(B4, B3);
			for (i = 0; i &lt; n; ++i) B3[i] = (ll)B3[i] * B2[i] % mod; DNTT(B3, B4);
			for (i = n &gt;&gt; 1; i &lt; n; ++i) c[i] = B4[n - i] * (mod - iv) % mod;
		}
	}
}

namespace PolyEvaluation {
	using namespace Poly;

	int cnt = 0, lc[N], rc[N];
	vec Prd_, E1, E2, E3, E4;
	vector g[N], tmp_;

	int solve(int L, int R) {
		if (L + 1 == R) return L;
		int M = (L + R) / 2, id = cnt++, lp = solve(L, M), rp = solve(M, R);
		Mul(g[lp], g[rp], g[id]);
		return lc[id] = lp, rc[id] = rp, id;
	}

	void recursion(int id, int L, int R, const vector &amp;poly) {
		if (L + 1 == R) return tmp_.EB(poly.back());
		int i, n = poly.size() - 1, M = (L + R) / 2, lp = lc[id], rp = rc[id],
			dl = min(n, g[lp].size() - 1), dr = min(n, g[rp].size() - 1);
		if (L + 2 == R) return
			tmp_.EB((poly[n] + (ll)poly[n - 1] * g[rp].back()) % mod),
			tmp_.EB((poly[n] + (ll)poly[n - 1] * g[lp].back()) % mod);

		vector ly, ry; ly.reserve(dl + 1), ry.reserve(dr + 1);
		NTT_init(lg2(dl + dr) + 1); ll iv = mod - (mod - 1) / Poly::n;
		memcpy(E1, poly.data(), (n + 1) &lt;&lt; 2), DNTT(E1, E2), memset(E1, 0, (n + 1) &lt;&lt; 2);

		memcpy(E1, g[rp].data(), (dr + 1) &lt;&lt; 2), DNTT(E1, E3), memset(E1, 0, (dr + 1) &lt;&lt; 2);
		for (i = 0; i &lt; Poly::n; ++i) E3[i] = (ll)E3[i] * E2[i] % mod;
		DNTT(E3, E4), std::reverse(E4 + 1, E4 + Poly::n);
		for (i = n - dl; i &lt;= n; ++i) ly.EB(E4[i] * iv % mod);

		memcpy(E1, g[lp].data(), (dl + 1) &lt;&lt; 2), DNTT(E1, E3), memset(E1, 0, (dl + 1) &lt;&lt; 2);
		for (i = 0; i &lt; Poly::n; ++i) E3[i] = (ll)E3[i] * E2[i] % mod;
		DNTT(E3, E4), std::reverse(E4 + 1, E4 + Poly::n);
		for (i = n - dr; i &lt;= n; ++i) ry.EB(E4[i] * iv % mod);

		recursion(lp, L, M, ly), recursion(rp, M, R, ry);
	}

	vector emain(int n, pvec f, const vector &amp;pts) {
		int i, id, m = pts.size(), q;
		if (!m) return vector();
		if (!n) return vector(m, *f);
		for (i = 0; i &lt; m; ++i) g[i].clear(), g[i].EB(1), g[i].EB(neg(q = pts[i]));

		id = solve(0, cnt = m), memcpy(Prd_, g[id].data(), (m + 1) &lt;&lt; 2);
		Inv(n + 1, Prd_, E2), memset(Prd_, 0, (m + 1) &lt;&lt; 2);
		if (n &gt; 0) memset(E2 + (n + 1), 0, (Poly::n - n - 1) &lt;&lt; 2);

		std::reverse_copy(f, f + (n + 1), E1), Mul(2 * n, E1, E2, E3),
		memset(E1, 0, (n + 1) &lt;&lt; 2), memset(E2, 0, (n + 1) &lt;&lt; 2);

		return tmp_.clear(), tmp_.reserve(m), recursion(id, 0, m, vector(E3 + max(n - m + 1, 0), E3 + (n + 1))), tmp_;
	}
}

namespace PolyInterpolation {
	using namespace PolyEvaluation;

	vec I1, I2, I3, I4, I5;
	pvec iresult;

	void irecursion(int id, int L, int R) {
		if (L + 1 == R) return;
		int i, M = (L + R) / 2, lp = lc[id], rp = rc[id];
		irecursion(lp, L, M), irecursion(rp, M, R);
		NTT_init(lg2(R - L - 1) + 1);
		ll iv = mod - (mod - 1) / Poly::n;
		memcpy(I1, iresult + L, (M - L) &lt;&lt; 2), memset(I1 + (M - L), 0, (Poly::n - (M - L)) &lt;&lt; 2);
		memcpy(I2, iresult + M, (R - M) &lt;&lt; 2), memset(I2 + (R - M), 0, (Poly::n - (R - M)) &lt;&lt; 2);
		memcpy(I3, g[lp].data(), (M - L + 1) &lt;&lt; 2), memset(I3 + (M - L + 1), 0, (Poly::n - (M - L + 1)) &lt;&lt; 2);
		memcpy(I4, g[rp].data(), (R - M + 1) &lt;&lt; 2), memset(I4 + (R - M + 1), 0, (Poly::n - (R - M + 1)) &lt;&lt; 2);
		DNTT(I1, I5), DNTT(I2, I1), DNTT(I3, I2), DNTT(I4, I3);
		for (i = 0; i &lt; Poly::n; ++i) I4[i] = ((ll)I1[i] * I2[i] + (ll)I3[i] * I5[i]) % mod;
		DNTT(I4, I5); std::reverse(I5 + 1, I5 + Poly::n);
		for (i = 0; i &lt; R - L; ++i) iresult[L + i] = I5[i] * iv % mod;
	}

	void imain(int n, pr *pts, pvec ret) {
		int i, id, q;
		assert(n &gt; 0);
		for (i = 0; i &lt; n; ++i) g[i].clear(), g[i].EB(1), g[i].EB(neg(q = pts[i].first));

		id = solve(0, cnt = n), memcpy(Prd_, g[id].data(), (n + 1) &lt;&lt; 2);
		Inv(n, Prd_, E2), memset(Prd_, 0, n &lt;&lt; 2);
		if (n &gt; 1) memset(E2 + n, 0, (Poly::n - n) &lt;&lt; 2);

		for (i = 0; i &lt; n; ++i) E1[i] = ll(n - i) * g[id][i] % mod;
		Mul(2 * (n - 1), E1, E2, E3),
		memset(E1, 0, n &lt;&lt; 2), memset(E2, 0, n &lt;&lt; 2);

		tmp_.clear(), tmp_.reserve(n), recursion(id, 0, n, vector(E3, E3 + n));
		for (i = 0; i &lt; n; ++i) ret[i] = PowerMod(tmp_[i], mod - 2, pts[i].second);
		iresult = ret, irecursion(id, 0, n), std::reverse(ret, ret + n);
	}
}
</code><script>syntax_highlight()</script>
</pre></div>
	</body>
</html>
