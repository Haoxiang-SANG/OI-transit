<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/sh_typical.min.css">
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/js/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
		<title>完整多项式模板</title>
	</head>
	<body>
		<h3>完整多项式模板 (乘除、指对、分治、求值、插值)</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">// This is a polynomial template for C++11
#include &lt;bits/stdc++.h&gt;
#define EB emplace_back
#define lg2 std::__lg

typedef long long ll;
const int N = 530000, mod = 998244353, iv2 = (mod + 1) / 2, root = 31;
typedef int vec[N], *pvec;
typedef std::pair &lt;int, int&gt; pr;
typedef std::vector &lt;int&gt; vector;

vec fact, inv, finv;

inline int &amp; reduce(int &amp;x) {return x += x &gt;&gt; 31 &amp; mod;}
ll PowerMod(ll a, int n, ll c = 1) {for (; n; n &gt;&gt;= 1, a = a * a % mod) if (n &amp; 1) c = c * a % mod; return c;}

void init() {
	int i;
	for (inv[1] = 1, i = 2; i &lt; N; ++i) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;
	for (*finv = *fact = i = 1; i &lt; N; ++i) fact[i] = (ll)fact[i - 1] * i % mod, finv[i] = (ll)finv[i - 1] * inv[i] % mod;
}

namespace Poly {
	int l, n;
	vec rev, x, y;

	// Input and output
	void in(int deg, pvec f) {for (int i = 0; i &lt;= deg; ++i) scanf("%d", f + i);}

	void out(int deg, pvec f, const char *_name) {
		printf("%s(x) =", _name);
		for (int i = 0; i &lt;= deg; ++i) printf(" %+d x^%d", (int)(f[i] - (mod &amp; -(f[i] &gt;= iv2))), i);
		putchar(10);
	}

	void series(int deg, pvec f) {for (int i = 0; i &lt;= deg; ++i) printf("%d%c", f[i], i == deg ? 10 : 32);}

	#define fy_out(deg, f) Poly::out(deg, f, #f)

	// Fast Number Theory Transform
	void NTT_init(int len) {
		if (l == len) return; n = 1 &lt;&lt; (l = len);
		ll g = PowerMod(root, 1 &lt;&lt; (23 - l));
		*x = 1, *rev = 0;
		for (int i = 1; i &lt; n; ++i)
			x[i] = x[i - 1] * g % mod, rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (l - 1);
	}

	void DNTT(int *d, int *t) {
		int i, *j, *k, len = 1, delta = n, R;
		for (i = 0; i &lt; n; ++i) t[rev[i]] = d[i];
		for (i = 0; i &lt; l; ++i) {
			delta &gt;&gt;= 1;
			for (k = x, j = y; j &lt; y + len; k += delta, ++j) *j = *k;
			for (j = t; j &lt; t + n; j += len &lt;&lt; 1)
				for (k = j; k &lt; j + len; ++k)
					R = (ll)y[k - j] * k[len] % mod,
					k[len] = (*k - R &lt; 0 ? *k - R + mod : *k - R),
					*k = (*k + R &gt;= mod ? *k + R - mod : *k + R);
			len &lt;&lt;= 1;
		}
	}

	vec B1, B2, B3, B4, B5, B6, B7;

	// Multiplication (use buffer 1)
	void Mul(int deg, pvec a, pvec b, pvec c) {
		if (!deg) {*c = (ll)*a * *b % mod; return;}
		NTT_init(lg2(deg) + 1);
		int i; ll iv = mod - (mod - 1) / n;
		DNTT(a, c), DNTT(b, B1);
		for (i = 0; i &lt; n; ++i) B1[i] = (ll)B1[i] * c[i] % mod;
		DNTT(B1, c), std::reverse(c + 1, c + n);
		for (i = 0; i &lt; n; ++i) c[i] = c[i] * iv % mod;
	}

	// Inversion (use buffer 1, 2, 3)
	void Inv(int deg, pvec a, pvec b) {
		int len, i; ll iv = iv2;
		if (!*a) fputs("Inv::Calculate inverse of polynomial with constant term 0 !\n", stderr), abort();
		*b = PowerMod(*a, mod - 2), b[1] = 0, *B1 = *a, B1[1] = a[1];
		for (len = 0; 1 &lt;&lt; len &lt; deg; ++len) {
			NTT_init(len + 2);
			memset(b + (n &gt;&gt; 1), 0, n &lt;&lt; 1), DNTT(b, B2);
			memset(B1 + (n &gt;&gt; 1), 0, n &lt;&lt; 1), DNTT(B1, B3);
			for (i = 0; i &lt; n; ++i) reduce(B2[i] = B2[i] * (2ll - (ll)B2[i] * B3[i] % mod) % mod);
			DNTT(B2, B3), std::reverse(B3 + 1, B3 + n), iv = (iv &gt;&gt; 1) + iv2;
			for (i = 0; i &lt; n &gt;&gt; 1; ++i) b[i] = B3[i] * iv % mod;
			memcpy(B1 + i, a + i, n &lt;&lt; 1);
		}
	}

	// Division and Modulo Operation (use buffer 4, 5)
	void DivMod(int degA, int degB, pvec a, pvec b, pvec q, pvec r) {
		if (degA &lt; degB) {memcpy(r, a, degA + 1 &lt;&lt; 2); memset(r + (degA + 1), 0, degB - degA &lt;&lt; 2); return;}
		int degQ = degA - degB, i, j = (degQ ? 1 &lt;&lt; lg2(degQ) + 2 : 4);
		for (i = 0; i &lt;= degQ &amp;&amp; i &lt;= degB; ++i) B4[i] = b[degB - i];
		for (; i &lt; j; ++i) B4[i] = 0;
		Inv(degQ + 1, B4, B5);
		for (i = 0; i &lt;= degQ; ++i) B4[i] = a[degA - i];
		for (; i &lt; n; ++i) B4[i] = B5[i] = 0;
		Mul(degQ * 2, B4, B5, q);
		std::reverse(q, q + (degQ + 1));
		NTT_init(lg2(degA) + 1);
		for (i = degQ + 1; i &lt; n; ++i) q[i] = 0;
		for (i = 0; i &lt;= degB; ++i) B4[i] = b[i];
		for (; i &lt; n; ++i) B4[i] = 0;
		Mul(degA, B4, q, r);
		for (i = 0; i &lt; degB; ++i) reduce(r[i] = a[i] - r[i]);
	}

	// Multiplication with std::vector (use buffer 1, 2, 3)
	void Mul(vector &amp;a, vector &amp;b, vector &amp;ret) {
		int degA = a.size() - 1, degB = b.size() - 1;
		if (!(degA || degB)) {ret.emplace_back((ll)a[0] * b[0] % mod); return;}
		NTT_init(lg2(degA + degB) + 1);
		int i; ll iv = mod - (mod - 1) / n;
		memcpy(B1, a.data(), (degA + 1) &lt;&lt; 2), memset(B1 + (degA + 1), 0, (n - degA - 1) &lt;&lt; 2);
		memcpy(B2, b.data(), (degB + 1) &lt;&lt; 2), memset(B2 + (degB + 1), 0, (n - degB - 1) &lt;&lt; 2);
		DNTT(B1, B3), DNTT(B2, B1);
		for (i = 0; i &lt; n; ++i) B1[i] = (ll)B1[i] * B3[i] % mod;
		DNTT(B1, B3), std::reverse(B3 + 1, B3 + n); ret.clear(), ret.reserve(degA + degB + 1);
		for (i = 0; i &lt;= degA + degB; ++i) ret.EB(B3[i] * iv % mod);
	}

	// Differential
	void Diff(int deg, pvec a, pvec b) {for (int i = 1; i &lt;= deg; ++i) b[i - 1] = (ll)a[i] * i % mod;}

	// Integral
	void Intg(int deg, pvec a, pvec b, int ct = 0) {for (int i = 1; i &lt;= deg; ++i) b[i] = (ll)a[i - 1] * inv[i] % mod; *b = ct;}

	// Logarithm (use buffer 4, 5, 6)
	void Ln(int deg, pvec a, pvec b) {
		if (*a != 1) fputs("Ln::Calculate logarithm of polynomial without constant term 1 !\n", stderr), abort();
		if (!--deg) {*b = 0; return;}
		int i, j = deg * 2 - 1; NTT_init(lg2(j) + 1);
		Diff(deg, a, B4), Inv(deg, a, B5);
		for (i = deg; i &lt; n; ++i) B4[i] = B5[i] = 0;
		Mul(j, B4, B5, B6), Intg(deg, B6, b);
	}

	// Exponentiation (use buffer 6, 7)
	void Exp(int deg, pvec a, pvec b) {
		int len, i, n = 2;
		if (*a) fputs("Exp::Calculate exponent of polynomial without constant term 0 !\n", stderr), abort();
		*b = 1, b[1] = 0;
		for (len = 0; 1 &lt;&lt; len &lt; deg; ++len, n &lt;&lt;= 1) {
			Ln(n, b, B7), *B7 = 1;
			for (i = 1; i &lt; n; ++i) reduce(B7[i] = a[i] - B7[i]);
			memset(B7 + n, 0, n &lt;&lt; 2), memset(b + n, 0, n &lt;&lt; 2);
			Mul((n &lt;&lt; 1) - 1, b, B7, B6), memcpy(b, B6, n &lt;&lt; 2);
		}
	}
}

namespace PolyEvaluation {
	using namespace Poly;

	int cnt = 0, lc[N], rc[N];
	vec Prd_, E1, E2, E3;
	vector g[N], tmp_;

	int solve(int L, int R) {
		if (L + 1 == R) return L;
		int M = (L + R) / 2, id = cnt++, lp = solve(L, M), rp = solve(M, R);
		Mul(g[lp], g[rp], g[id]);
		return lc[id] = lp, rc[id] = rp, id;
	}

	void recursion(int id, int L, int R, const vector &amp;poly) {
		if (L + 1 == R) return tmp_.EB(poly.back());
		int i, n = poly.size() - 1, M = (L + R) / 2, lp = lc[id], rp = rc[id],
			dl = min(n, g[lp].size() - 1), dr = min(n, g[rp].size() - 1);
		if (L + 2 == R) return
			tmp_.EB((poly[n] + (ll)poly[n - 1] * g[rp].back()) % mod),
			tmp_.EB((poly[n] + (ll)poly[n - 1] * g[lp].back()) % mod);

		NTT_init(lg2(n + dr) + 1);
		ll iv = mod - (mod - 1) / Poly::n;
		vector pntt(Poly::n, 0), nxt;
		memcpy(E1, poly.data(), (n + 1) &lt;&lt; 2), DNTT(E1, pntt.data()), memset(E1, 0, (n + 1) &lt;&lt; 2);

		memcpy(E2, g[rp].data(), (dr + 1) &lt;&lt; 2), DNTT(E2, E3);
		for (i = 0; i &lt; Poly::n; ++i) E3[i] = (ll)E3[i] * pntt[i] % mod;
		DNTT(E3, E2), std::reverse(E2 + 1, E2 + Poly::n);
		nxt.clear(), nxt.reserve(dl + 1);
		for (i = n - dl; i &lt;= n; ++i) nxt.EB(E2[i] * iv % mod);
		memset(E2, 0, (n + dr + 1) &lt;&lt; 2), recursion(lp, L, M, nxt);

		NTT_init(lg2(n + dr) + 1);
		memcpy(E2, g[lp].data(), (dl + 1) &lt;&lt; 2), DNTT(E2, E3);
		for (i = 0; i &lt; Poly::n; ++i) E3[i] = (ll)E3[i] * pntt[i] % mod;
		DNTT(E3, E2), std::reverse(E2 + 1, E2 + Poly::n);
		nxt.clear(), nxt.reserve(dr + 1);
		for (i = n - dr; i &lt;= n; ++i) nxt.EB(E2[i] * iv % mod);
		memset(E2, 0, (n + dl + 1) &lt;&lt; 2), recursion(rp, M, R, nxt);
	}

	vector emain(int n, pvec f, const vector &amp;pts) {
		int i, id, m = pts.size(), q;
		if (!m) return vector();
		if (!n) return vector(m, *f);
		for (i = 0; i &lt; m; ++i) g[i].clear(), g[i].EB(1), g[i].EB(neg(q = pts[i]));

		id = solve(0, cnt = m), memcpy(Prd_, g[id].data(), (m + 1) &lt;&lt; 2);
		Inv(n + 1, Prd_, E2), memset(Prd_, 0, (m + 1) &lt;&lt; 2);
		if (n &gt; 0) memset(E2 + (n + 1), 0, (Poly::n - n - 1) &lt;&lt; 2);

		std::reverse_copy(f, f + (n + 1), E1), Mul(2 * n, E1, E2, E3),
		memset(E1, 0, (n + 1) &lt;&lt; 2), memset(E2, 0, (n + 1) &lt;&lt; 2);

		return tmp_.clear(), tmp_.reserve(m), recursion(id, 0, m, vector(E3 + max(n - m + 1, 0), E3 + (n + 1))), tmp_;
	}
}

namespace PolyInterpolation {
	using namespace PolyEvaluation;

	vec I1, I2, I3, I4, I5;
	pvec iresult;

	void irecursion(int id, int L, int R) {
		if (L + 1 == R) return;
		int i, M = (L + R) / 2, lp = lc[id], rp = rc[id];
		irecursion(lp, L, M), irecursion(rp, M, R);
		NTT_init(lg2(R - L - 1) + 1);
		ll iv = mod - (mod - 1) / Poly::n;
		memcpy(I1, iresult + L, (M - L) &lt;&lt; 2), memset(I1 + (M - L), 0, (Poly::n - (M - L)) &lt;&lt; 2);
		memcpy(I2, iresult + M, (R - M) &lt;&lt; 2), memset(I2 + (R - M), 0, (Poly::n - (R - M)) &lt;&lt; 2);
		memcpy(I3, g[lp].data(), (M - L + 1) &lt;&lt; 2), memset(I3 + (M - L + 1), 0, (Poly::n - (M - L + 1)) &lt;&lt; 2);
		memcpy(I4, g[rp].data(), (R - M + 1) &lt;&lt; 2), memset(I4 + (R - M + 1), 0, (Poly::n - (R - M + 1)) &lt;&lt; 2);
		DNTT(I1, I5), DNTT(I2, I1), DNTT(I3, I2), DNTT(I4, I3);
		for (i = 0; i &lt; Poly::n; ++i) I4[i] = ((ll)I1[i] * I2[i] + (ll)I3[i] * I5[i]) % mod;
		DNTT(I4, I5); std::reverse(I5 + 1, I5 + Poly::n);
		for (i = 0; i &lt; R - L; ++i) iresult[L + i] = I5[i] * iv % mod;
	}

	void imain(int n, pr *pts, pvec ret) {
		int i, id, q;
		assert(n &gt; 0);
		for (i = 0; i &lt; n; ++i) g[i].clear(), g[i].EB(1), g[i].EB(neg(q = pts[i].first));

		id = solve(0, cnt = n), memcpy(Prd_, g[id].data(), (n + 1) &lt;&lt; 2);
		Inv(n, Prd_, E2), memset(Prd_, 0, n &lt;&lt; 2);
		if (n &gt; 1) memset(E2 + n, 0, (Poly::n - n) &lt;&lt; 2);

		for (i = 0; i &lt; n; ++i) E1[i] = ll(n - i) * g[id][i] % mod;
		Mul(2 * (n - 1), E1, E2, E3),
		memset(E1, 0, n &lt;&lt; 2), memset(E2, 0, n &lt;&lt; 2);

		tmp_.clear(), tmp_.reserve(n), recursion(id, 0, n, vector(E3, E3 + n));
		for (i = 0; i &lt; n; ++i) ret[i] = PowerMod(tmp_[i], mod - 2, pts[i].second);
		iresult = ret, irecursion(id, 0, n), std::reverse(ret, ret + n);
	}
}
</code><script>syntax_highlight()</script>
</pre></div>
	</body>
</html>
