<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/sh_typical.min.css">
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script type="text/javascript" src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
		<title>坑点总结</title>
		<style type="text/css">
			.table-text-center>thead>tr>th {text-align: center}
			.table-text-center>tbody>tr>td {text-align: center}
			.table-vertical-middle>thead>tr>th {vertical-align: middle}
			.table-vertical-middle>tbody>tr>td {vertical-align: middle}
		</style>
	</head>
	<body>
		<h3>坑点总结</h3>
		<p>ps: 红色代表<strong style="color: red">全局坑</strong>，绿色代表<strong style="color: green">算法坑</strong>，蓝色代表<strong style="color: blue">考场坑</strong>。</p>
		<table class="table table-bordered table-text-center table-vertical-middle">
			<thead>
				<tr>
					<th style="width: 7%">编号</th>
					<th style="width: 79%">内容</th>
					<th style="width: 7%">重要程度</th>
					<th style="width: 7%">被坑频率</th>
				</tr>
			</thead>
			<tbody>
				<tr style="color: red">
					<td>1</td>
					<td>计算数组大小和内存限制，适当调整数组大小</td>
					<td>95 %</td>
					<td>60 %</td>
				</tr>
				<tr style="color: red">
					<td>2</td>
					<td>计算答案长度，适当开 <code>long long</code> 和 <code>%lld</code></td>
					<td>95 %</td>
					<td>60 %</td>
				</tr>
				<tr style="color: red">
					<td>3</td>
					<td>理清每一步在干嘛，比如循环中不要明明对 $i$ 操作达成了 $j$</td>
					<td>90 %</td>
					<td>50 %</td>
				</tr>
				<tr style="color: red">
					<td>4</td>
					<td>线段树空间 $\times 4$，无向边空间 $\times 2$，dfs 序空间 $\times 2$，<del>后缀自动机空间 $\times 2$</del>，很多什么预处理的时候空间也要乘一个常数</td>
					<td>85 %</td>
					<td>50 %</td>
				</tr>
				<tr style="color: red">
					<td>5</td>
					<td>用 <code>fread()</code> 时，提前 (根据数据的最坏情况) 就算最大文件大小，适当的开 <code>buf[]</code> 数组，如果发现空间非常紧，改用 <code>getchar()</code>/<del><code>fgetc()</code></del></td>
					<td>90 %</td>
					<td>45 %</td>
				</tr>
				<tr style="color: red">
					<td>6</td>
					<td>动态规划或其它玩意儿时要注意各种边界、特判和能转移的条件，不然可能会 WA 得很厉害 (尤其是多组数据)</td>
					<td>90 %</td>
					<td>45 %</td>
				</tr>
				<tr style="color: red">
					<td>7</td>
					<td>对于多组数据的情况，一定要分清楚哪些变量/数组在跑完一组数据后要重置 (比如邻接表的 <code>first[]</code> 数组，如果实在搞不清楚且运行时间足够的话，把所有涉及到的变量都重置。因此，对拍器不要只拍 $T = 1$</td>
					<td>90 %</td>
					<td>45 %</td>
				</tr>
				<tr style="color: red">
					<td>8</td>
					<td>注意题目中的如 $\sum n \leq 10^5$ 等特殊的条件，它们往往是突破口，需要发掘特殊的性质。</td>
					<td>80 %</td>
					<td>40 %</td>
				</tr>
				<tr style="color: red">
					<td>9</td>
					<td>需要改循环变量的名称时所有的变量改到底，不要 <code>j = 0; j &lt; n;</code> 后面还是 <code>++i</code>，同样升序/降序遍历切换的时候不要忘记切换 <code>++</code>/<code>--</code></td>
					<td>80 %</td>
					<td>35 %</td>
				</tr>
				<tr style="color: red">
					<td>10</td>
					<td>在答案需要模一个数时 (尤其是像 $10^9 + 7$ 这种比较大的数)，要及时取模，避免乘三次爆 <code>long long</code> 了。</td>
					<td>80 %</td>
					<td>30 %</td>
				</tr>
				<tr style="color: red">
					<td>11</td>
					<td>在设置 (<code>int</code> 的) <code>INF</code> 或者 <code>memset()</code> 到无穷大时，最好 <code>INF = 0x3f3f3f3f</code> 或者 <code>memset(a, 63, sizeof a);</code>/<code>memset(a, 192, sizeof a);</code>。设成 <code>INT_MIN</code>/<code>INT_MAX</code> 可能会因为某些加法操作而溢出 (如 Floyd)，当然 INF 的设置还要<strong>因题而异</strong> (有的需要设大，有的不能设大)</td>
					<td>80 %</td>
					<td>30 %</td>
				</tr>
				<tr style="color: red">
					<td>12</td>
					<td>下标是 $0 \sim n-1$ 还是 $1 \sim n$ 记清楚，不要读入的时候 $0 \sim n-1$，而跑算法的时候 $1 \sim n$。</td>
					<td>75 %</td>
					<td>35 %</td>
				</tr>
				<tr style="color: red">
					<td>13</td>
					<td>对于 STL，能手写就手写，常数至少快 $3$ 倍，除了 <code>sort()</code> 和 <code>__gnu_pbds::priority_queue &lt;&gt;</code>，<code>bitset</code> 有时间手写。</td>
					<td>70 %</td>
					<td>30 %</td>
				</tr>
				<tr style="color: red">
					<td>14</td>
					<td>使用 <code>memset</code>/<code>memcpy</code> 等函数时考虑复杂度，不要以为库里面的都是 $O(1)$ 的</td>
					<td>65 %</td>
					<td>25 %</td>
				</tr>
				<tr style="color: blue">
					<td>15</td>
					<td><code>&lt;bits/stdc++.h&gt;</code> 已放开使用，可以使用它。如果不使用，必须<strong>确保所有需要的头文件都包含</strong>，并且变量命名不冲突，尤其是一些 Windows 和 Linux <strong>头文件内部包含情况不同</strong>的情况 (如 Windows 中 <code>&lt;cstdlib&gt;</code> 包含 <code>&lt;climits&gt;</code>，而 Linux 中并没有)</td>
					<td>+&#8734; %</td>
					<td>99 %</td>
				</tr>
				<tr style="color: blue">
					<td>16</td>
					<td>合理安排考试时间，不能一道题上处理太久 (3 题时间均匀分配，不要一个公式推了 1 个小时)</td>
					<td>90 %</td>
					<td>40 %</td>
				</tr>
				<tr style="color: blue">
					<td>17</td>
					<td>题目写完还有剩余时间做对拍器，可以查出一些比较智障的错误，当然还要手动造一些易 hack 数据和极限数据做测试</td>
					<td>85 %</td>
					<td>40 %</td>
				</tr>
				<tr style="color: blue">
					<td>18</td>
					<td>交上去的代码中调试信息一定要删掉 (注释掉)！尤其是在一些 <code>if</code> 中才会有的调试信息！</td>
					<td>90 %</td>
					<td>25 %</td>
				</tr>
				<tr style="color: blue">
					<td>19</td>
					<td>正确计算时间复杂度，$O(n^2)$ 能过的就不要优化到 $O(n)$ 甚至 $O(1)$ (尤其是代码量变大，调试难度增大且花费大量时间的时候)</td>
					<td>80 %</td>
					<td>30 %</td>
				</tr>
				<tr style="color: green">
					<td>20</td>
					<td>DP 转移方程尽量先写在纸上<del>或画图板上</del>，避免转移的时候突然忘记乘 $2$ 等等而失去大量分数</td>
					<td>85 %</td>
					<td>40 %</td>
				</tr>
				<tr style="color: green">
					<td>21</td>
					<td>涉及到浮点数的二分、计算几何等，根据题目合理设置 <code>eps</code>，不能太小也不能太大</td>
					<td>80 %</td>
					<td>35 %</td>
				</tr>
				<tr style="color: green">
					<td>22</td>
					<td>在写 <code>hash_set</code>/<code>hash_map</code> 或边邻接表等时，如果数组有 $0$ 号元素，一定要记得把初始的 <code>first[]</code> 数组置为 $-1$ (或其它未出现元素)</td>
					<td>80 %</td>
					<td>35 %</td>
				</tr>
				<tr style="color: green">
					<td>23</td>
					<td>在排序一个结构体的情况下，以某一维作第一关键字时，一定要判断是否要以某一维按照第二关键字再排序，有的题是需要的！</td>
					<td>85 %</td>
					<td>30 %</td>
				</tr>
				<tr style="color: green">
					<td>24</td>
					<td>动态规划不要一下 <code>for</code> 到底，分析有用的状态<del>或用记忆化搜索</del>有时能大幅降低复杂度，还有压缩/滚动的时候判断可行性和遍历的顺序。</td>
					<td>80 %</td>
					<td>30 %</td>
				</tr>
				<tr style="color: green">
					<td>25</td>
					<td>如果结构体的比较函数被定义为运算符，那么在使用 <code>sort()</code> 的时候必须用两个 const 关键字，否则在 Linux 中很可能编译不过去。</td>
					<td>80 %</td>
					<td>25 %</td>
				</tr>
				<tr style="color: green">
					<td>26</td>
					<td>处理区间 $[L, R], [L, R), (L, R], (L, R)$ 的时候注意边界，同样一些 $+ 1$ 和 $- 1$ 的情况也要注意</td>
					<td>75 %</td>
					<td>30 %</td>
				</tr>
				<tr style="color: green">
					<td>27</td>
					<td>分块的时候，如果左端点 $l$ 大于右端点 $r$ 是需要特判的，这种情况说明 $a, b$ 在同一个块内，直接暴力即可。</td>
					<td>75 %</td>
					<td>25 %</td>
				</tr>
				<tr style="color: green">
					<td>28</td>
					<td>在拓扑序中，点 $i$ 后面的点的集合并非点 $i$ 所能到达的点的集合</td>
					<td>75 %</td>
					<td>25 %</td>
				</tr>
				<tr style="color: green">
					<td>29</td>
					<td>图论中，无向边的 [奇-偶] 存储还是 [偶-奇] 存储搞清楚，以便找反边的时候不会找错</td>
					<td>70 %</td>
					<td>25 %</td>
				</tr>
				<tr style="color: green">
					<td>30</td>
					<td>不是所有逆元都是 <code>PowerMod(a, mod - 2)</code>，看条件有没有说模数一定是素数 (给的常数模通常是素数，但也不乏很多合数的情况)</td>
					<td>70 %</td>
					<td>25 %</td>
				</tr>
				<tr style="color: green">
					<td>31</td>
					<td>Dinic 网络流在 <code>dfs()</code> 的时候必须加上引用！</td>
					<td>65 %</td>
					<td>25 %</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
