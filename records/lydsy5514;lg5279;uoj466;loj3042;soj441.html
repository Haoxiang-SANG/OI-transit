<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/sh_typical.min.css">
		<title>[lydsy5514][lg5279][uoj466][loj3042][soj441][ZJOI2019]麻将</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/js/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>今天，可怜想要打麻将，但是她的朋友们都去下自走棋了，因此可怜只能自己一个人打。可怜找了一套特殊的麻将，它有 $n$ ($n \geq 5$) 种不同的牌，大小分别为 $1$ 到 $n$，每种牌都有 $4$ 张。</p>
		<p>定义面子为三张大小相同或者大小相邻的麻将牌，即大小形如 $i, i, i$ ($1 \leq i \leq n$) 或者 $i, i + 1, i + 2$ ($1 \leq i \leq n - 2$)。</p>
		<p>定义对子为两张大小相同的麻将牌，即大小形如 $i, i$ ($1 \leq i \leq n$)。</p>
		<p>定义一个麻将牌集合 $S$ 是<strong>胡的</strong>当且仅当它的大小为 $14$ 且满足下面两个条件中的至少一个：</p>
		<ol>
			<li><p>$S$ 可以被划分成五个集合 $S_1$ 至 $S_5$。其中 $S_1$ 为对子，$S_2$ 至 $S_5$ 为面子。</p></li>
			<li><p>$S$ 可以被划分成七个集合 $S_1$ 至 $S_7$，它们都是对子，且对应的大小<strong>两两不同</strong>。</p></li>
		</ol>
		<p>举例来说，下列集合都是胡的 (这儿只标记了大小)：</p>
		<ol>
			<li>$\left\{ 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9 \right\}$</li>
			<li>$\left\{ 1, 1, 2, 2, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 \right\}$</li>
			<li>$\left\{ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7 \right\}$</li>
		</ol>
		<p>而下列集合都不是胡的：</p>
		<ol>
			<li>$\left\{ 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9 \right\}$</li>
			<li>$\left\{ 1, 1, 1, 1, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 \right\}$</li>
			<li>$\left\{ 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9, 11 \right\}$</li>
		</ol>
		<p>可怜先摸出了 $13$ 张牌，并把剩下的 $4 n - 13$ 张牌随机打乱。打乱是等概率随机的，即所有 $\left( 4 n - 13 \right) !$ 种排列都等概率出现。</p>
		<p>对于一个排列 $P$，可怜定义 $S_i$ 为可怜事先摸出的 $13$ 张牌加上 $P$ 中的前 $i$ 张牌构成的集合，定义 $P$ 的权值为<strong>最小的 $i$ 满足 $S_i$ 存在一个子集是胡的</strong>。如果你对麻将比较熟悉，不难发现 $P$ 的权值就是理论上的最早胡牌巡目数。注意到 $n \geq 5$ 的时候，$S_{4 n - 13}$ 总是存在胡的子集的，因此 $P$ 的权值是良定义的。</p>
		<p>现在可怜想要训练自己的牌效，因此她希望你能先计算出 $P$ 的权值的期望是多少。</p>

		<h3>输入格式</h3>
		<p>第一行包含一个正整数 $n$ ($5 \leq n \leq 100$)，表示这副特殊的麻将牌中的大小种类数。</p>
		<p>接下来的 $13$ 行，每行包含两个整数 $w, t$ ($1 \leq w \leq n; 1 \leq t \leq 4$)，表示可怜最开始摸出的第 $i$ 张牌是大小为 $w$ 的第 $t$ 张牌。保证二元组 $\left( w, t \right)$ 两两不同。</p>

		<h3>输出格式</h3>
		<p>输出一行一个整数，表示答案对 $998244353$ 取模后的值。</p>

		<h3>题解</h3>
		<p>先考虑如何判定一些牌构成的集合 $S$ 是否<strong>存在胡的子集</strong>。</p>
		<p>考虑按照大小<strong>从小到大</strong>进行处理。用 $f_{w, i, j}$ 表示当前已经处理完 $\leq w$ 的所有数，且剩下<strong>将要与后面的牌匹配成顺子的</strong> $\left( w - 1, w, \cdots \right)$ 有 $i$ 组 (即这 $i$ 组将会形成 $\left( w - 1, w, w + 1 \right)$，$\left( w, \cdots \right)$ 有 $j$ 组 (即这 $j$ 组将会形成 $\left( w, w + 1, w + 2 \right)$ 的情况下，当前已经匹配完成的<strong>面子</strong> (顺子 + 刻子) 数的最大值。</p>
		<p>可以注意到，$i, j &lt; 3$。否则，比如说 $i \geq 3$，意思是会形成三个顺子 —— $\left( w, w + 1, w + 2 \right)$，不妨将其改成三个刻子 —— $w^3, \left( w + 1 \right)^3, \left( w + 2 \right)^3$，不影响面子的数目。$j \geq 3$ 时同理。</p>
		<p>至于转移，考察有多少个 $w + 1$。首先，它至少需要有 $i + j$ 个。否则这些顺子就无法归位。</p>
		<p>对于多余的 $w + 1$，我们枚举有多少个是去组成顺子 $\left( w + 1, w + 2, w + 3 \right)$，然后对于剩下的 $w + 1$，显然是贪心地组成刻子 <del>(除以 $3$ 下取整)</del>，剩下的牌就没用了。</p>
		<p>当然，在状态中还要记录当前是否已经确定<em>将眼</em> (就是那个一对的 $S_1$，好像没有正式名称)，以及 (不同大小的) 对子数量。</p>
		<p>具体的 DP 方程这里就不再写出来了。最后只需判断对子数量是否达到 $7$，以及是否存在某个 (已经确定将眼的) $f_{w, i, j} \geq 4$。</p>
		<p>这个 DP 的时间复杂度是 $O \left( n \cdot 2 \cdot 3^2 \right)$ 的。</p>
		<hr />
		<p>然而原题并不是判断一个给定的集合是否存在胡的子集，而是存在 "加牌" 的操作。</p>
		<p>首先根据套路，我们讲<strong>整型随机变量的期望</strong>转化成<strong>概率的问题</strong>。即有多大的概率，摸了 $i - 13$ 张牌 ($13 \leq i \leq 4 n$，即当前共有 $i$ 张牌) 后仍然不胡。</p>
		<p>将概率变成计数，也就是：对于所有长度为 $i$，且初始 $13$ 张麻将给定的麻将排列 (共 $\left( 4 n - 13 \right)^{\underline {i - 13}} = \dfrac {\left( 4 n - 13 \right)!} {\left( 4 n - i \right)!}$ 种)，有多少个排列是<strong>不存在胡的子集</strong>的。</p>
		<p>设这样的排列有 $p_i$ 种，那么摸了 $i - 13$ 张牌后仍然不胡的概率就是 $p_i$ 就等于 $\dfrac {p_i \cdot \left( 4 n - i \right)!} {\left( 4 n - 13 \right)!}$。</p>
		<p>于是最终的答案就只需要讲所有 $i$ 求和，即 $\displaystyle \sum_{i=13}^{4 n} \frac {p_i \cdot \left( 4 n - i \right)!} {\left( 4 n - 13 \right)!}$。</p>
		<p>于是问题的关键在于求 $p_i$。</p>
		<p>对于是排列，如果按照顺序添加元素，那么就很难判胡了。因为刚才我们的判定是从小到大加牌的。</p>
		<p>因此，这里我们也考虑<strong>从小到大加牌</strong>。由于大小相同的四张牌是不同的，于是我们可以将问题 (排列) 转化为选一个包含给定集合的 $i$ 元集 (组合)，最后乘上一个 $\left( i - 13 \right)!$。</p>
		<p>这样一来，DP 时就需要在状态中记录上一个 DP 的值了 (即 DP 套 DP！)，大体就是用 $g_{w, \mathbf f, t}$ 表示加完了 $\leq w$ 的所有数，当前 DP 数组为 $\mathbf f$，共有 $t$ 个对子<strong>且不胡</strong>的方案数。</p>
		<p>还是要注意到大小相同的四张牌是不同的，因此在枚举大小为 $w + 1$ 的牌有多少个的时候，不要忘记乘上一个适当的组合数 (二项式系数)。</p>
		<p>时间复杂度 $O \left( n \cdot 4^{2 \cdot 3^2} \cdot 7 \right)$，已经无法接受。</p>
		<hr />
		<p>那怎么办呢？显然把整个 DP 数组塞到状态里面来一看就非常愚蠢啊！通常有大量 DP 数组是不可能出现的，况且还可能存在大量 DP 数组是胡牌等价的！</p>
		<p>冷静分析一下，可以发现，其实第一个 DP 过程可以看成在一个<strong>有限状态自动机</strong>上匹配的过程。状态集合 $S$ 就是所有 DP 数组 $\mathbf f$ 构成的集合，"字符集" $\Sigma = \left\{ 0, 1, 2, 3, 4 \right\}$ 表示下一个大小的牌出现多少张，转移函数 $d$ 就是 DP 状态之间的转移，初始状态 $s_0 = \mathbf 0$，接受状态集合 $F$ 即所有胡牌的集合——即满足 "$t \geq 7$ 或存在已经确定将眼的 $f_{w, i, j} \geq 4$" 的所有 $\mathbf f$ 构成的集合。</p>
		<p>至于这个自动机收到的 "串" $c_1 c_2 \cdots c_n$，就表示每张牌 $i$ 的出现次数 $c_i$。</p>
		<p>而且，在 DP 套 DP 的过程中，难道不觉得和<strong>在自动机上 DP 很像</strong>吗？</p>
		<p>因此，我们要讲这个<del>辣鸡</del> DP 套 DP 转化成<strong>在自动机上 DP</strong>。</p>
		<p>而众所周知，<strong>有限状态自动机</strong> (DFA) 是存在<a href="../index.html?redirect=579" target="_blank"><strong>最小化</strong></a>的，而一个最小化自动机和它本身<strong>所识别的串的集合完全相同</strong>。也就是说，如果一个 "串" 被原自动机 "判胡"，<strong>当且仅当</strong>它被最小化自动机 "判胡"。</p>
		<p>于是我们所要做的，就是对这个自动机进行 "最小化"。</p>
		<p>我们使用一般自动机的最小化算法 (在<a href="../index.html?redirect=579" target="_blank">这里</a>也提到过)，也可以使用 dfs 等方法求出这个自动机的最小化。时间复杂度大约是 $O \left( \left| S \right|^2 \left| \Sigma \right| \cdot 2 \cdot 3^2 \right)$，不过实测跑得挺快的。</p>
		<p>由 Myhill-Nerode 定理，一个<strong>接受串</strong>集合固定的 DFA (如果存在) 的最小化在同构意义下唯一。因此，不管你是用哪种算法构造出来的，只要是最小自动机，同构意义下长得都一样。对于 "胡牌检验自动机" 来说，它的最小化的状态数为 $2092$，且 $\left| F \right| = 1$ <del>(可以用来 check 一下)</del>。</p>
		<p>于是只需在最小化自动机上 DP，DP 的时间复杂度就降为 $O \left( n^2 \left| S' \right| \right)$，就可以通过了。</p>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define MAM mahjong_automaton

typedef long long ll;
const int N = 108, N4 = N * 4, S = 2100, mod = 998244353;
const int C[5][5] = {{1, 0, 0, 0, 0}, {1, 1, 0, 0, 0}, {1, 2, 1, 0, 0}, {1, 3, 3, 1, 0}, {1, 4, 6, 4, 1}};

namespace mahjong_automaton {
	typedef unsigned long long u64, status;
	typedef std::unordered_map &lt;status, int&gt; map;
	const u64 mask1 = 0111111111ull, mask2 = 0222222222ull, mask4 = 0444444444ull, mask7 = 0777777777ull;

	int cnt = 0, d[S][5];
	map f;

	inline int min(const int x, const int y) {return x &lt; y ? x : y;}
	inline void up(char &amp;x, const char y) {x &lt; y ? x = y : 0;}
	inline bool HU(status x) {return x &gt;&gt; 54 &gt;= 7 || (x = (x &gt;&gt; 27 &amp; mask7) ^ mask2, x &amp; (~x - mask1) &amp; mask4);}

	status trans(status cur, int v) {
		int i, j, k, d, c, o = 0;
		static char f[2][3][3];
		status nxt = (u64)min((cur &gt;&gt; 54) + (v &gt;= 2), 7) &lt;&lt; 54;
		memset(f, -1, sizeof f);
		for (i = 0; i &lt; 2; ++i)
			for (j = 0; j &lt; 3; ++j)
				for (k = 0; k &lt; 3; ++k, o += 3)
					if (c = (cur &gt;&gt; o &amp; 7) - 1, ~c) {
						for (d = 0; d &lt; 3 &amp;&amp; j + k + d &lt;= v; ++d)
							up(f[i][k][d], min(c + j + (j + k + d + 3 &lt;= v), 4));
						for (d = 0; d &lt; 3 &amp;&amp; !i &amp;&amp; j + k + d &lt;= v - 2; ++d)
							up(f[1][k][d], min(c + j, 4));
					}
		for (o = i = 0; i &lt; 2; ++i)
			for (j = 0; j &lt; 3; ++j)
				for (k = 0; k &lt; 3; ++k, o += 3) nxt |= (f[i][j][k] + 1ull) &lt;&lt; o;
		return nxt;
	}

	int dfs(status x) {
		if (HU(x)) return 0;
		map::iterator it = f.find(x);
		if (it != f.end()) return it-&gt;second;
		int i, c = ++cnt; f.emplace(x, c);
		for (i = 0; i &lt;= 4; ++i) d[c][i] = dfs(trans(x, i));
		return c;
	}

	inline void init() {f.reserve(S), f.rehash(2003731), dfs(1);}
}

int n;
int c[N], fact[N * 4], finv[N * 4];
int dp[2][N * 4][S], (*cur)[S] = *dp, (*nxt)[S] = dp[1];

ll PowerMod(ll a, int n, ll c = 1) {for (; n; n &gt;&gt;= 1, a = a * a % mod) if (n &amp; 1) c = c * a % mod; return c;}

void init(int n) {
	int i;
	for (*fact = i = 1; i &lt;= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;
	finv[n] = PowerMod(fact[n], mod - 2);
	for (i = n; i; --i) finv[i - 1] = (ll)finv[i] * i % mod;
}

int main() {
	int i, j, ni, nj, d, w, S, tot; ll s;
	MAM::init();
	scanf("%d", &amp;n), init(4 * n);
	for (i = 0; i &lt; 13; ++i) scanf("%d%*d", &amp;w), ++c[--w];
	for (nxt[0][1] = 1, w = 0; w &lt; n; ++w) {
		std::swap(cur, nxt), memset(nxt, 0, sizeof *dp), tot += c[w];
		for (i = 0; i &lt;= 4 * w; ++i)
			for (j = 1; j &lt;= MAM::cnt; ++j) if ((s = cur[i][j]))
				for (d = 0; d &lt;= 4 - c[w]; ++d)
					ni = i + c[w] + d, nj = MAM::d[j][c[w] + d],
					nj &amp;&amp; (nxt[ni][nj] = (nxt[ni][nj] + s * C[4 - c[w]][d]) % mod);
	}
	for (S = 0, i = 13; i &lt; 4 * n; ++i)
		s = std::accumulate(nxt[i] + 1, nxt[i] + MAM::cnt, 0ll) % mod,
		S = (S + s * fact[i - 13] % mod * fact[4 * n - i]) % mod;
	printf("%lld\n", (ll)S * finv[4 * n - 13] % mod);
	return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
		<p><strong>坑1：</strong>在自动机上搜索的时候，状态可以压到一个 $64$ 位整数 (<code>long long</code>) 中，这样顺便也可以使用 <code>unordered_map</code> (<samp>hash_map</samp>)。</p>
		<p><strong>坑2：</strong>由于我们要统计的是<strong>不胡</strong>的方案数，因此如果自动机转移到了终止节点 (胡牌节点)，则是不能更新 DP 数组的。</p>
	</body>
</html>
