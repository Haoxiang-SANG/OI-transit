<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/sh_typical.min.css">
		<title>[lydsy3837][PA2013]Filary</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>给定 $n$ 个正整数，你需要从中挑出 $k$ 个数，满足：存在某一个正整数 $m$ ($m \geq 2$)，使得这 $k$ 个数模 $m$ 的余数相等。</p>
		<p>求出 $k$ 的最大值，并求出此时的 $m$。如果有多组解使得 $k$ 最大，你要在此基础上求出 $m$ 的最大值。</p>

		<h3>输入格式</h3>
		<p>第一行包含一个正整数 $n$ ($2 \leq n \leq 10^5$)，表示数的个数，</p>
		<p>第二行包含 $n$ 个正整数 $w_i$ ($1 \leq w_i \leq 10^7$)，表示这 $n$ 个数，保证至少存在两个数不相等。</p>

		<h3>输出格式</h3>
		<p>输出一行，包含两个整数 $k, m$，表示 $k$ 的最大值和在 $k$ 取最大值时 $m$ 的最大值。</p>

		<h3>题解</h3>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define gcd std::__gcd

const int N = 100054, D = 10000054, P = 665432;

int n;
int a[N], apr[P], mx[P];
int appear = 0, max = 0;
int pn = 0, c[D], p[P];

void sieve(int n) {
	int i, j, v; memset(c, -1, sizeof c);
	for (i = 2; i &lt;= n; ++i) {
		if (!~c[i]) p[pn] = i, c[i] = pn++;
		for (j = 0; (v = i * p[j]) &lt;= n &amp;&amp; j &lt;= c[i]; ++j) c[v] = j;
	}
}

void solve(int x) {
	int i, j, u, v, tot = 0;
	for (i = 0; i &lt; n; ++i)
		if ((u = abs(a[i] - x))) 
			for (v = u; v != 1; ++apr[j], mx[j] = gcd(mx[j], u))
				for (j = c[v]; !(v % p[j]); v /= p[j]);
		else ++tot;
	for (i = 0; i &lt; pn; apr[i] = mx[i] = 0, ++i)
		if (apr[i] + tot &gt; appear) appear = apr[i] + tot, max = mx[i];
		else if (apr[i] + tot == appear &amp;&amp; mx[i] &gt; max) max = mx[i];
}

int main() {
	int i; sieve(D - 1);
	char *_ = new char; srand(time(NULL) + (unsigned long)_), delete _;
	scanf("%d", &amp;n);
	for (i = 0; i &lt; n; ++i) scanf("%d", a + i);
	for (i = 0; i &lt; 12; ++i) solve(a[rand() % n]);
	printf("%d %d\n", appear, max);
	return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
	</body>
</html>
