<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/sh_typical.min.css">
		<title>[soj157]糕</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>「蛋糕是最好吃的！」喜欢吃蛋糕但还是很瘦的 NanoApe 这样说道。</p>
		<p>一天，NanoApe 买了 $n$ 个蛋糕，每个蛋糕都有一个美味值，美味值越高表示蛋糕越好吃。</p>
		<p>NanoApe 想分成几次吃掉，但她十分挑剔。对于每次吃的蛋糕，其中最难吃的蛋糕和最好吃的蛋糕的美味值之差为这次的口感指数。只有当多次的口感指数之和不超过 $K$ 的时候，NanoApe 才会觉得开心。</p>
		<p>现在 NanoApe 想知道有多少种吃蛋糕的方法能让她开心，她好从其中随机选择一种方案来吃蛋糕。</p>

		<h3>输入格式</h3>
		<p>第一行包含两个非负整数 $n, K$ ($1 \leq n \leq 200; 0 \leq K \leq 1000$) 分别表示蛋糕的个数和多次的口感指数之和的上限。</p>
		<p>第二行包含 $n$ 个正整数 $A_i$ ($1 \leq A_i \leq 500$)，表示第 $i$ 个蛋糕的美味值。</p>

		<h3>输出格式</h3>
		<p>输出一行一个整数，表示方案数。方案数有可能很大，只需输出其模 $10^9 + 7$ 后的值即可。</p>

		<h3>题解</h3>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define N 205
#define M 1005
typedef long long ll;
const ll mod = 1000000007;

int n, K;
int c[N];
int f[N][N][M];

/* f[i][j][k]: the count of ways of """
	current at position i (sorted), the count of '-' is j more than that of '+', the algebra sum of the signs equals to k 
""" */

inline void add(int &amp;x, const int y) {x = (x + y &gt;= mod ? x + y - mod : x + y);}
inline void up(int &amp;x, const int y) {x &lt; y ? x = y : 0;}
inline void down(int &amp;x, const int y) {x &gt; y ? x = y : 0;}

int main() {
	int i, j, k, scx, ans = 0;
	scanf("%d%d", &amp;n, &amp;K);
	for (i = 1; i &lt;= n; ++i) scanf("%d", c + i);
	std::sort(c + 1, c + (n + 1));
	f[0][0][0] = 1;
	for (i = 0; i &lt; n; ++i)
		for (j = 0; j &lt;= i; ++j)
			for (k = 0; k &lt;= K; ++k)
				if (f[i][j][k]) {
					if ((scx = k + (c[i + 1] - c[i]) * j) &gt; K) continue;
					// 1. two new signs ('+'/'-') on one position i+1
					add(f[i + 1][j][scx], f[i][j][k]);
					// 2. place position i+1 at a ['-', '+'] range
					if (j) add(f[i + 1][j][scx], f[i][j][k] * (ll)j % mod);
					// 3. create sign '+' on position i+1
					if (j) add(f[i + 1][j - 1][scx], f[i][j][k] * (ll)j % mod);
					// 4. create sign '-' on positoin i+1
					add(f[i + 1][j + 1][scx], f[i][j][k]);
					
				}
	for (k = 0; k &lt;= K; ++k) add(ans, f[n][0][k]);
	printf("%d\n", ans);
	return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
	</body>
</html>
