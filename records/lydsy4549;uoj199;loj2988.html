<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/sh_typical.min.css">
		<title>[lydsy4549][uoj199][loj2988][CTSC2016]Suffix Array</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>小 P 来到了 NOIP2044 的赛场上，他发现第二题的题目是这样的：给你一个长度为 $n$ 的字符串，该字符串由至多 $m$ 种不同的字符组成，其中第 $i$ 种字符的出现次数不超过 $c_i$，问你这个字符串的后缀数组是什么。</p>
		<p>聪明的小 P 想到了一个新的问题希望你来帮忙解答：在题目给定的限制下，能有多少种不同的答案。也就是所有由 $m$ 种字符组成，其中第 $i$ 种字符出现次数不超过 $c_i$，且长度为 $n$ 的字符串，共有多少种不同的后缀数组。</p>
		<p>由于答案很大，你只用输出答案对 $10^9 + 7$ 取模后的值。</p>
		<p>对于字符串之间的大小关系，我们规定第 $1$ 个字符最小，第 $2$ 个字符次小，以此类推。</p>

		<h3>输入格式</h3>
		<p>第一行包含两个正整数 $n, m$ ($n, m \leq 500$)，表示字符串的长度为 $n$，共有 $m$ 种字符。</p>
		<p>第二行包含 $m$ 个非负整数 $c_1, c_2, \cdots, c_m$ ($0 \leq c_i \leq m; \sum c_i \geq m$)，表示每种字符最多的出现次数。</p>

		<h3>输出格式</h3>
		<p>输出一行一个整数，表示不同后缀数组的个数模 $10^9 + 7$ 的值。</p>

		<h3>题解</h3>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define jl j
#define kl k

typedef long long ll;
const int N = 540, mod = 1000000007;

int n, m;
int c[N], fact[N], finv[N];
int f[N][N], F[N][N];

inline void add(int &amp;x, const int y) {x = (x + y &gt;= mod ? x + y - mod : x + y);}
ll PowerMod(ll a, int n, ll c = 1) {for (; n; n &gt;&gt;= 1, a = a * a % mod) if (n &amp; 1) c = c * a % mod; return c;}

int main() {
	int i, j, k, l; ll ans = 0;
	scanf("%d%d", &amp;n, &amp;m);
	for (i = 1; i &lt;= m; ++i) if (scanf("%d", c + i), !c[i]) --i, --m;
	for (*fact = i = 1; i &lt;= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;
	finv[n] = PowerMod(fact[n], mod - 2);
	for (i = n; i; --i) finv[i - 1] = (ll)finv[i] * i % mod;
	for (**f = i = 1; i &lt;= m; ++i) {
		for (j = 0; j &lt;= n; ++j)
			for (k = 0; k &lt;= j; ++k)
				add(F[j + 1][k + 1] = F[j][k], f[j][k] + (f[j][k] &gt;&gt; 31 &amp; mod)), f[j][k] = 0;
		for (jl = 1; jl &lt;= n; ++jl)
			for (kl = 1; kl &lt;= jl; ++kl) {
				l = std::min(c[i], kl);
				f[jl][0] = (f[jl][0] + (ll)finv[kl] * (F[jl][kl] - F[jl - l][kl - l])) % mod;
				if (jl != n) {
					l = std::min(c[i] - 1, kl),
					f[jl][kl] = ((ll)f[jl][kl] - F[jl][kl] + F[jl - l][kl - l]) % mod;
				}
			}
		ans += f[n][0];
	}
	ans = ans % mod * fact[n] % mod;
	printf("%lld\n", ans + (ans &gt;&gt; 63 &amp; mod));
	return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
	</body>
</html>
