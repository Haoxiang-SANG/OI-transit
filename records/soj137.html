<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/sh_typical.min.css">
		<title>[soj137]B 君的第九题</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>对于一个排列 $a_1, a_2, \cdots, a_n$，如果对于一个 $i$ ($1 \leq i \leq n$) 满足 $a_{i-1} &lt; a_i &gt; a_{i+1}$，则称 $i$ 是一个极大值。</p>
		<p><strong>我们认为 $a_0 = a_{n+1} = 0$。</strong></p>
		<p>考虑 $1, 2, \cdots, n$ 的所有排列，问有多少个排列恰好有 $m$ 个极大值。</p>
		<p>输出答案对 $p$ 取模的结果，$p$ 是输入的一个数字，<strong>不保证是质数</strong>。</p>

		<h3>输入格式</h3>
		<p>共一行，包含三个正整数 $n, m, p$ ($1 \leq n \leq 10^9; 1 \leq m \leq 10; 2 \leq p \leq 1001$)。</p>

		<h3>输出格式</h3>
		<p>输出一行一个整数，表示答案。</p>

		<h3>题解</h3>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define N 100005

typedef long long ll;

int n, K, mod;
int f[N][11];

struct matrix {
	int a[11][11];
	matrix () {memset(a, 0, sizeof a);}
	matrix operator * (const matrix &amp;B){
		matrix ret; int i, j, k;
		for (i = 1; i &lt;= K; ++i)
			for (j = 1; j &lt;= K; ++j)
				for (k = 1; k &lt;= K; ++k)
					ret.a[i][j] = (ret.a[i][j] + a[i][k] * B.a[k][j]) % mod;
		return ret;
	}
} u, v;

matrix PowerMod(matrix a, int n) {
	matrix ret; int i;
	for (i = 1; i &lt;= K; ++i) ret.a[i][1] = 1;
	for (; n; n &gt;&gt;= 1, a = a * a)
		if (n &amp; 1) ret = a * ret;
	return ret;
}

inline void trans(int i) {
	for (int j = 1; j &lt;= K; ++j) {
		f[i][j] = ((ll)j * 2 * (f[i - 1][j] - f[i - 1][j - 1]) + (ll)i * f[i - 1][j - 1]) % mod;
		f[i][j] += f[i][j] &gt;&gt; 31 &amp; mod;
	}
}

int main() {
	int i, j, k, ans;
	scanf("%d%d%d", &amp;n, &amp;K, &amp;mod);
	for (k = 1; k &lt;= K; ++k) {
		for (j = 1; j &lt;= K; ++j) f[1][j] = k == j;
		for (i = 2; i &lt;= mod + 1; ++i) trans(i);
		for (j = 1; j &lt;= K; ++j) u.a[j][k] = f[mod + 1][j];
	}
	v = PowerMod(u, --n / mod);
	n %= mod;
	for (j = 1; j &lt;= K; ++j) f[1][j] = v.a[j][1];
	for (i = 2; i &lt;= n + 1; ++i) trans(i);
	ans = f[n + 1][K] - f[n + 1][K - 1];
	printf("%d\n", ans + (ans &gt;&gt; 31 &amp; mod));
	return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
	</body>
</html>
