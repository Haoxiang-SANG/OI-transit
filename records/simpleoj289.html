<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/sh_typical.min.css">
		<title>[SimpleOJ289]句读之王</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script type="text/javascript" src="../additional_files/sh_main.min.js"></script>
		<script type="text/javascript" src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>句读之王很喜欢句读，她的院子里有两棵树，一棵是橘子树，另一棵也是橘子树。</p>
		<p>句读之王比较喜欢第一棵橘子树，这棵橘子树有 $n$ 个节点标号为 $1, 2, \cdots, n$，并通过 $n-1$ 根枝条连接成一个连通的图。<strong>一开始树上的每个节点都没有橘子</strong>。</p>
		<p>每经过 $1 \texttt s$，第 $i$ 个节点就会长出 $a_i$ 颗新的橘子。每个节点的橘子数量也有一个上限 $b_i$，如果某一时刻某个节点的橘子个数超过上限，那么超过上限的橘子就会消失。</p>
		<p>句读之王擅长把橘子变成豆子。如果某一个节点有 $x$ 颗橘子，那么句读之王可以把它们变成 $f(x)$ 颗豆子。$f(x)$ 定义为的最大的完全平方数 $y$ 满足 $y$ 是 $x$ 的因数。特别地，$f(0) = 0$。</p>
		<p>可能在某些时刻，她会选择一些节点，对每一个节点，她会把每个节点上面的橘子全部变成豆子，然后摘下来，把得到的豆子喂给她的宠物海蜇吃。<strong>(注意：是先把每个节点的橘子变成豆子再摘下来，而不是先全部摘下来再变成豆子)</strong></p>
		<p>句读之王一共会进行 $m$ 次操作，这些操作按照时间给出，且同一时刻她最多只能进行一次操作。现在她想知道，每一轮操作海蜇吃了几颗豆子。为了方便，你只需要输出所有答案的和即可。<del>如果你不会做这道题，那么给句读之王买两个橘子，也是可以的。</del></p>

		<h3>输入格式</h3>
		<p>第一行包含两个正整数 $n, m$ ($n, m \leq 10^5$)，表示树上节点的个数和接下来操作的个数。</p>
		<p>第二行包含 $n$ 个非负整数 $a_i$ ($a_i \leq 10^5$)，分别表示第 $i$ 个节点每秒钟会生长出的橘子的个数。</p>
		<p>第三行包含 $n$ 个非负整数 $b_i$ ($b_i \leq 2 \times 10^{10}$)，分别表示第 $i$ 个节点橘子数量的上限。</p>
		<p>接下来 $n-1$ 行，每行包含两个正整数 $x_i, y_i$，表示第 $i$ 根枝条连接的两个节点。</p>
		<p>接下来 $m$ 行每行三个正整数 $X_i, Y_i, t_i$ ($t_i \leq 3 \times 10^5$)，表示选择所有位于 $X_i \sim Y_i$ 最短路上的节点，这个操作发生在第 $t_i$ 秒。保证 $t_i &lt; t_{i+1}$。</p>

		<h3>输出格式</h3>
		<p>输出一行一个整数，表示所有答案的和。</p>

		<h3>题解</h3>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define N 100034
#define M 256101
#define Q 2048808
#define gcd __gcd
using namespace std;

typedef long long ll;

struct unit{
	int v; ll l, lans;
	unit (int v0 = 0, ll l0 = 0, ll lans0 = 0): v(v0), l(l0), lans(lans0) {}
}a[N];

struct request{
	int l, r, t;
	request (int l0 = 0, int r0 = 0, int t0 = 0): l(l0), r(r0), t(t0) {}
	inline bool operator &lt; (const request &amp;B) const {return l &lt; B.l || (l == B.l &amp;&amp; r &lt; B.r);}
}r[Q];

int cct = 0;
int n, q, qq, E, i;
int u, v, t;
int scx_v[N], ord[Q]; ll scx_l[N];
ll z, ans = 0;

inline bool cmp(const int A, const int B) {return r[A].r &lt; r[B].r || (r[A].r == r[B].r &amp;&amp; r[A].l &lt; r[B].l);}

namespace HLD{
	int to[M], first[N], next[M];
	int p[N], dep[N], size[N];
	int cnt = 0, id[N], prf[N], top[N];

	inline void addedge(int u, int v){
		to[++E] = v; next[E] = first[u]; first[u] = E;
		to[++E] = u; next[E] = first[v]; first[v] = E;
	}

	void dfs_wt(int x){
		int i, y, &amp;z = prf[x];
		size[x] = 1;
		for(i = first[x]; i; i = next[i])
			if((y = to[i]) != p[x]){
				p[y] = x; dep[y] = dep[x] + 1;
				dfs_wt(y);
				size[y] &gt; size[z] ? z = y : 0;
				size[x] += size[y];
			}
	}

	void dfs_hld(int x, int r){
		int i, y;
		id[x] = ++cnt; top[x] = r;
		if(!prf[x]) return;
		dfs_hld(prf[x], r);
		for(i = first[x]; i; i = next[i])
			if(!top[y = to[i]])
				dfs_hld(y, y);
	}

	void decomposition(int u, int v, int t){
		int x = top[u], y = top[v];
		for(; x != y; u = p[x], x = top[u]){
			if(dep[x] &lt; dep[y]) {swap(u, v); swap(x, y);}
			r[++q] = request(id[x], id[u], t);
		}
		if(dep[u] &gt; dep[v]) swap(u, v);
		r[++q] = request(id[u], id[v], t);
	}
}

namespace lych{
	const int MAX = 341468;
	
	int pn, c[3001], p[432], u[MAX];
	
	void init(){
		int i, j, v;
		pn = 0;
		memset(c, 0, sizeof c);
		for(i = 2; i &lt;= 3000; i++){
			if(!c[i]) p[pn++] = i;
			for(j = 0; j &lt; pn; j++){
				if((v = i * p[j]) &gt; 3000) break;
				c[v] = p[j];
				if(!(i % p[j])) break;
			}
		}
		u[0] = 0;
		for(i = 1; (v = i * i) &lt; MAX; ++i)
			for(j = v; j &lt; MAX; j += v)
				u[j] = v;
	}
	
	ll ak(ll n){
		if(n &lt; MAX) return u[n];
		int i, j; ll r = 1, s;
		for(i = 0; i &lt; pn; ++i)
			for(j = 0; !(n % p[i]); n /= p[i], ++j)
				if(j &amp; 1) r = r * p[i] * p[i];
		s = (ll)sqrtl(n);
		if(s * s == n) r = r * n;
		return r;
	}
}

namespace scx{
	typedef set &lt;int&gt; Set;
	typedef map &lt;int, int&gt; Map;
	typedef pair &lt;int, int&gt; pr;

	Set stamp;
	Map diff; int cnt;

	inline void add(int key, int value){
		Map::iterator it = diff.find(key);
		if(it == diff.end()) diff.insert(pr(key, 1));
		else if(it-&gt;second + value) it-&gt;second += value;
		else diff.erase(it);
		cnt += value;
	}

	void insert(int t){
	//	printf("+ %d\n", t);
		Set::iterator i = stamp.lower_bound(t), j; --(j = i);
		if(i != stamp.end()) {add(*i - *j, -1); add(*i - t, 1);}
		add(t - *j, 1);
		stamp.insert(t);
	}

	void erase(int t){
	//	printf("- %d\n", t);
		Set::iterator i = stamp.find(t), j, k; ++(j = i); --(k = i);
		if(j != stamp.end()) {add(*j - t, -1); add(*j - *k, 1);}
		add(t - *k, -1);
		stamp.erase(i);
	}

	ll query(int id){
		int sz = cnt, D;
		ll ret = 0, t = (a[id].v ? a[id].l / a[id].v : LLONG_MAX);
		Map::iterator it = diff.begin();
		for(; it != diff.end() &amp;&amp; it-&gt;first &lt;= t; sz -= it-&gt;second, ++it){
			D = gcd(a[id].v, it-&gt;first);
			ret += (ll)lych::ak(a[id].v / D) * lych::ak(it-&gt;first / D) * D * D * it-&gt;second;
		}
		ret += (ll)sz * a[id].lans;
		return ret;
	}
}

int main(){
	scanf("%d%d", &amp;n, &amp;qq);
	for(i = 1; i &lt;= n; ++i) scanf("%d", scx_v + i);
	for(i = 1; i &lt;= n; ++i) scanf("%lld", scx_l + i);
	for(i = 1; i &lt; n; ++i) {scanf("%d%d", &amp;u, &amp;v); HLD::addedge(u, v);}
	HLD::dfs_wt(1); HLD::dfs_hld(1, 1);
	lych::init();
	for(i = 1; i &lt;= n; ++i){
		z = lych::ak(scx_l[i]);
		a[HLD::id[i]] = unit(scx_v[i], scx_l[i], z);
	}
	for(; qq; --qq) {scanf("%d%d%d", &amp;u, &amp;v, &amp;t); HLD::decomposition(u, v, t);}
	for(i = 1; i &lt;= q; ++i) ord[i] = i;
	sort(r, r + (q + 1));
	sort(ord + 1, ord + (q + 1), cmp);
	u = v = 1;
	scx::stamp.insert(0);
	for(i = 1; i &lt;= n; ++i){
		for(; v &lt;= q &amp;&amp; r[ord[v]].r == i - 1; ++v) scx::erase(r[ord[v]].t);
		for(; u &lt;= q &amp;&amp; r[u].l == i; ++u) scx::insert(r[u].t);
		ans += scx::query(i);
	}
	printf("%lld\n", ans);
	return 0;
}
</code><script type="text/javascript">syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
	</body>
</html>
