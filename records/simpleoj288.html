<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/sh_typical.min.css">
		<title>[SimpleOJ288]掘地求升</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script type="text/javascript" src="../additional_files/sh_main.min.js"></script>
		<script type="text/javascript" src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p><del>你在 ois 手机应用商店 pap sotre 下载了一款名为 "掘地求升" 的游戏。</del></p>
		<p>游戏的地图可以抽象为下底面周长为 $n$ ($n &gt; 1$)，高度为 $m$ ($m &gt; 1$) 的<strong>圆柱体</strong>。你要在圆柱的外表面上努力攀登。</p>
		<p>圆柱体的外表面被分成 $n \times m$ 个方格 ，每个方格上有一些金币，按照自下而上，从上看逆时针的方向给出每个位置上金币的个数 ($A_{i, j}$)。</p>
		<p><strong>你可以任意选择第一行的某个格子作为起点</strong>，而每一步可以选择向上、左上或右上攀登一步，到达第 $m$ 层时游戏结束。假设你每一步获得金币数量的积为 $X$。</p>
		<p>同时，这个圆柱体还是一个好看的圆柱体。圆柱体的每一列被涂成了红 ($\tt r$) ，蓝 ($\tt b$)，白 ($\tt w$) 三种颜色之一。</p>
		<p>在你进行游戏时有两个奖励参数 $a, b$，<strong>初始值为 $1$</strong>。每当你经过一个红色的格子 (即这个格子所在的列被涂成了红色)，$a$ 的值增加 $1$；每当你经过一个蓝色的格子，$b$ 的值增加 $1$。</p>
		<p>为了鼓励玩家打出高 ping 的操作，游戏的奖励值还与 Combo 有关。Combo 指的是所有极长相同连续操作长度的乘积，具体地说：</p>
		<ul>
		<li><p>用 $\texttt{U, L, R}$ 分别表示向上、左上、右上攀登一步的操作，按照操作顺序我们可以得到一个字符串 (如果我们的操作是：上、上、左上、右上、右上、右上、左上，那么对应的字符串就是 $\texttt{UULRRRL}$)。</p></li>
		<li><p>将得到的字符串求出所有极长子串的长度 (如 $\texttt{UULRRRL}$ 就是 $(2,1,3,1)$)。</p></li>
		<li><p>那么 Combo 的值就是这些长度的乘积 ($\texttt{UULRRRL}$ 的 Combo 就是 $2 \times 1 \times 3 \times 1 = 6$)。</p></li>
		</ul>
		<p>一局游戏结束后，你的得分就是 $X \times a \times b \times \mathrm{Combo}$。你并不知道怎么玩才能得到最高的分数，因此你决定每一步随机选择三个方向中的一个，那么最后你得到的分数的期望是多少呢？你只需要输出答案$\times n \times 3^{m-1}$ 对 $998244353$ 取模后的值。</p>

		<h3>输入格式</h3>
		<p>第一行包含两个正整数 $n, m$ ($n, m \leq 2000$)，表示圆柱体的周长和高。</p>
		<p>第二行一个长度为 $n$ 的字符串，表示每一列被涂成的颜色。保证仅由 $\texttt{r, b, w}$ 组成。
		<p>接下来 $m$ 行，每行 $n$ 个正整数 $A_{i, j}$ ($A_{i, j} \leq 10^9$)，第 $i$ 行第 $j$ 列表示从下往上第 $i$ 行，从上方看逆时针的第 $j$ 个格子中的金币个数。</p>

		<h3>输出格式</h3>
		<p>输出一行一个整数，表示得分期望$\times n \times 3^{m-1}$ 对 $998244353$ 取模后的值。</p>

		<h3>题解</h3>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define N 2034
using namespace std;

typedef long long ll;
const ll mod = 998244353;

int n, h;
int a[N][N];
char col[N];
ll f[N][N][3][8];
// f[i][j][k][(b_2 b_1 b_0)_2]: Y = i, X = j, Dir = k, (Continuous, Red, Blue) Combo = (b_2, b_1, b_0)

inline int prev(int x) {return (x ? x : n) - 1;}
inline int succ(int x) {return x + 1 == n ? 0 : x + 1;}
inline void add(ll &amp;x, const ll y) {(x += y) &gt;= mod ? x -= mod : 0;}

void combo(int i){ // height
	int j, k, b;
	for(j = 0; j &lt; n; ++j) // Position X
		for(k = 0; k &lt; 3; ++k){ // Direction
			ll *dp = f[i][j][k]; add(dp[4], dp[0]); add(dp[5], dp[1]); add(dp[6], dp[2]); add(dp[7], dp[3]); // Continuous Combo
			if(col[j] == 114)   {add(dp[2], dp[0]); add(dp[3], dp[1]); add(dp[6], dp[4]); add(dp[7], dp[5]);} // Red Combo
			if(col[j] == 98)    {add(dp[1], dp[0]); add(dp[3], dp[2]); add(dp[5], dp[4]); add(dp[7], dp[6]);} // Blue Comb
			for(b = 0; b &lt; 8; ++b) dp[b] = dp[b] * a[i][j] % mod; // Weight
		}
}

int dp(){
	int i, j, k, nj, nk, b;
	ll result = 0;
	for(i = 0; i &lt; n; ++i)
		for(j = 0; j &lt;= (col[i] == 114); ++j)
			for(k = 0; k &lt;= (col[i] == 98); ++k){
				f[2][prev(i)][0][j &lt;&lt; 1 | k] = a[1][i];
				f[2][     i ][1][j &lt;&lt; 1 | k] = a[1][i];
				f[2][succ(i)][2][j &lt;&lt; 1 | k] = a[1][i];
			}
	combo(2);
	for(i = 2; i &lt; h; ++i){
		for(j = 0; j &lt; n; ++j) // Position X
			for(k = 0; k &lt; 3; ++k) // Old Direction
				for(nk = 0; nk &lt; 3; ++nk){ // New Direction
					nj = (nk ? (nk == 1 ? j : succ(j)) : prev(j)); // New Position
					for(b = 0; b &lt; 4; ++b) // Color Combo
						if(k == nk){ // Same Direction
							add(f[i + 1][nj][nk][b], f[i][j][k][b]);
							add(f[i + 1][nj][nk][b | 4], f[i][j][k][b | 4]);
						}else
							add(f[i + 1][nj][nk][b], f[i][j][k][b | 4]);
				}
		combo(i + 1);
	}
	for(j = 0; j &lt; n; ++j)
		for(k = 0; k &lt; 3; ++k)
			for(b = 4; b &lt; 8; ++b)
				add(result, f[h][j][k][b]);
	return printf("%lld\n", result), 0;
}

int main(){
	int i, j;
	scanf("%d%d%s", &amp;n, &amp;h, col);
	for(i = 1; i &lt;= h; ++i)
		for(j = 0; j &lt; n; ++j)
			scanf("%d", a[i] + j);
	return dp();
}
</code><script type="text/javascript">syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
	</body>
</html>
